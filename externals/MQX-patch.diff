diff --git a/externals/MQX_4_1/config/twrk70f120m/user_config.h b/externals/MQX_4_1/config/twrk70f120m/user_config.h
index 3c79a13..17d044a 100644
--- a/externals/MQX_4_1/config/twrk70f120m/user_config.h
+++ b/externals/MQX_4_1/config/twrk70f120m/user_config.h
@@ -1,28 +1,33 @@
-/*HEADER**********************************************************************
+/**HEADER**********************************************************************
 *
-* Copyright 2008 Freescale Semiconductor, Inc.
+* Copyright (c) 2008 Freescale Semiconductor;
+* All Rights Reserved
 *
-* This software is owned or controlled by Freescale Semiconductor.
-* Use of this software is governed by the Freescale MQX RTOS License
-* distributed with this Material.
-* See the MQX_RTOS_LICENSE file distributed for more details.
+*******************************************************************************
 *
-* Brief License Summary:
-* This software is provided in source form for you to use free of charge,
-* but it is not open source software. You are allowed to use this software
-* but you cannot redistribute it or derivative works of it in source form.
-* The software may be used only in connection with a product containing
-* a Freescale microprocessor, microcontroller, or digital signal processor.
-* See license agreement file for full license terms including other
-* restrictions.
-*****************************************************************************
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+*******************************************************************************
+*
+* $FileName: user_config.h$
+* $Version : 3.8.15.0$
+* $Date    : Sep-5-2012$
 *
 * Comments:
 *
 *   User configuration for MQX components
 *
-*
-*END************************************************************************/
+*END**************************************************************************/
 
 #ifndef __user_config_h__
 #define __user_config_h__
@@ -30,20 +35,15 @@
 /* mandatory CPU identification */
 #define MQX_CPU                 PSP_CPU_MK70F120M
 
-/* BSPCFG_ENABLE_LEGACY_II2C_SLAVE is the flag to enable interrupt driven i2c
-   slave driver.
-   If it's enabled, the driver will register interrupt handler to corresponding
-   I2C SDA pin muxing port vector, and please make sure your application would not
-   register handler on same interrupt vector.
- */
-#define BSPCFG_ENABLE_LEGACY_II2C_SLAVE     0
+/* Silicon version number */
+#define MK70_REV_1_0             1
 
 /* MGCT: <generated_code> */
 #define BSPCFG_ENABLE_TTYA       0
 #define BSPCFG_ENABLE_ITTYA      0
 #define BSPCFG_ENABLE_TTYB       0
 #define BSPCFG_ENABLE_ITTYB      0
-#define BSPCFG_ENABLE_TTYC       1
+#define BSPCFG_ENABLE_TTYC       0
 #define BSPCFG_ENABLE_ITTYC      0
 #define BSPCFG_ENABLE_TTYD       0
 #define BSPCFG_ENABLE_ITTYD      0
@@ -51,24 +51,27 @@
 #define BSPCFG_ENABLE_ITTYE      0
 #define BSPCFG_ENABLE_TTYF       0
 #define BSPCFG_ENABLE_ITTYF      0
-#define BSPCFG_ENABLE_I2C0       1
-#define BSPCFG_ENABLE_II2C0      1
+#define BSPCFG_ENABLE_I2C0       0
+#define BSPCFG_ENABLE_II2C0      0
 #define BSPCFG_ENABLE_I2C1       0
 #define BSPCFG_ENABLE_II2C1      0
 #define BSPCFG_ENABLE_SPI0       0
 #define BSPCFG_ENABLE_SPI1       0
 #define BSPCFG_ENABLE_SPI2       0
-#define BSPCFG_ENABLE_RTCDEV     1
+#define BSPCFG_ENABLE_RTCDEV     0
 #define BSPCFG_ENABLE_PCFLASH    0
 #define BSPCFG_ENABLE_ADC0       0
-#define BSPCFG_ENABLE_ADC1       1
+#define BSPCFG_ENABLE_ADC1       0
 #define BSPCFG_ENABLE_ADC2       0
 #define BSPCFG_ENABLE_ADC3       0
 #define BSPCFG_ENABLE_FLASHX     0
 #define BSPCFG_ENABLE_ESDHC      1
-#define BSPCFG_ENABLE_IODEBUG    0
+
+#define BSP_DEFAULT_IO_CHANNEL "iodebug:"
+#define BSPCFG_ENABLE_IODEBUG    1
+
 #define BSPCFG_ENABLE_NANDFLASH  0
-#define BSPCFG_ENABLE_SAI        1
+#define BSPCFG_ENABLE_SAI        0
 
 #define MQX_USE_UNCACHED_MEM     1
 #define MQX_USE_LWMEM_ALLOCATOR  0
@@ -89,12 +92,12 @@
 #define FTPDCFG_USES_MFS         1
 #define RTCSCFG_ENABLE_SNMP      0
 
+#define RTCSCFG_ENABLE_DNS       1
+
 #define TELNETDCFG_NOWAIT        FALSE
 
 #define MQX_TASK_DESTRUCTION     1
 
-#define MQX_USE_TIMER            1
-
 /* MGCT: </generated_code> */
 
 #define ENETCFG_SUPPORT_PTP      0
@@ -102,8 +105,17 @@
 /*
 ** include common settings
 */
-#define MQX_USE_IO_OLD          1
 
+//------------------------------------------------
+//FIT overwrite default settings:
+#define MQX_USE_SEMAPHORES                  1
+#define MQX_KERNEL_LOGGING                  1
+#define MQX_EXTRA_TASK_STACK_ENABLE         1
+#define MQX_USE_TIMER                       1
+#define MQX_USE_SW_WATCHDOGS                1
+#define BSPCFG_ENABLE_DCU4                  0
+
+//------------------------------------------------
 
 /* use the rest of defaults from small-RAM-device profile */
 #include "small_ram_config.h"
diff --git a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/bsp_cm.c b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/bsp_cm.c
index 6ba608b..9ace336 100644
--- a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/bsp_cm.c
+++ b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/bsp_cm.c
@@ -1,21 +1,27 @@
-/*HEADER**********************************************************************
+/**HEADER********************************************************************
 *
-* Copyright 2011 Freescale Semiconductor, Inc.
+* Copyright (c) 2011 Freescale Semiconductor;
+* All Rights Reserved
 *
-* This software is owned or controlled by Freescale Semiconductor.
-* Use of this software is governed by the Freescale MQX RTOS License
-* distributed with this Material.
-* See the MQX_RTOS_LICENSE file distributed for more details.
+***************************************************************************
 *
-* Brief License Summary:
-* This software is provided in source form for you to use free of charge,
-* but it is not open source software. You are allowed to use this software
-* but you cannot redistribute it or derivative works of it in source form.
-* The software may be used only in connection with a product containing
-* a Freescale microprocessor, microcontroller, or digital signal processor.
-* See license agreement file for full license terms including other
-* restrictions.
-*****************************************************************************
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+**************************************************************************
+*
+* $FileName: bsp_cm.c$
+* $Version : 3.8.8.0$
+* $Date    : Jun-6-2012$
 *
 * Comments:
 *   Clock manager Kinetis BSP specific definitions and function prototypes.
@@ -26,7 +32,12 @@
 *       _bsp_get_clock();
 *       _bsp_osc_autotrim();
 *
-*
+* Aenderung:
+* 12.03.2013 Ergänzung in __pe_initialize_hardware. M: Suter
+* 04.06.2013 OSC1_CR ERCLKEN auf Null setzen. M. Suter
+* 03.07.2013 PE_low_level_init(void) modifiziert für I-300 M. Bürki
+* 03.07.2013 __pe_initialize_hardware(void) modifiziert M. Bürki
+* 03.07.2013 OSC1 Komplett abgeschaltet da im I-300 nicht benötigt und nicht vorhanden
 *END************************************************************************/
 
 #include <mqx.h>
@@ -50,6 +61,43 @@ extern const TCpuClockConfiguration PE_CpuClockConfigurations[CPU_CLOCK_CONFIG_N
 #define ERR_PARAM_MODE  CM_ERR_PARAM_MODE       /* Invalid mode. */
 
 
+
+
+//#define PE_WFI()        _ASM_WFI()
+
+/* The following code is copied from the code generated by Processor Expert */
+
+/*
+** ===================================================================
+** Global HAL types and constants
+** ===================================================================
+*/
+//typedef uint32_t    LDD_TPinMask;         /* Pin mask type. */
+//typedef uint16_t    LDD_TError;           /* Error type. */
+//typedef uint32_t    LDD_TEventMask;       /* Event mask type. */
+//typedef uint8_t     LDD_TClockConfiguration; /* CPU clock configuration type. */
+
+//typedef void LDD_TDeviceData;          /* Pointer to private device structure managed and used by HAL components. */
+
+//typedef void LDD_TData;                /* General pointer to data. */
+
+//typedef void LDD_TUserData;            /* Pointer to this type specifies the user or RTOS specific data will be passed as an event or callback parameter. */
+/*
+typedef enum {
+  DOM_NONE,
+  DOM_RUN,
+  DOM_WAIT,
+  DOM_SLEEP,
+  DOM_STOP
+} LDD_TDriverOperationMode;     */       /* Driver operation mode type. */
+
+//typedef uint16_t LDD_TDriverState;     /* Driver state type. */
+
+//typedef void LDD_TCallbackParam;       /* Pointer to this type specifies the user data to be passed as a callback parameter. */
+//typedef void (* LDD_TCallback)(LDD_TCallbackParam *CallbackParam); /* Callback type used for definition of callback functions. */
+
+
+
 /* Symbols representing MCG modes */
 #define MCG_MODE_FBI                    0x00U
 #define MCG_MODE_BLPI                   0x01U
@@ -118,8 +166,6 @@ const TCpuClockConfiguration PE_CpuClockConfigurations[CPU_CLOCK_CONFIG_NUMBER]
 };
 
 /* Global variables */
-volatile uint8_t SR_reg;               /* Current value of the FAULTMASK register */
-volatile uint8_t SR_lock = 0x00U;      /* Lock */
 static uint8_t ClockConfigurationID = CPU_CLOCK_CONFIG_0; /* Active clock configuration */
 
 
@@ -346,14 +392,17 @@ static void Cpu_SetMCGModePEE(uint8_t CLKMode)
       OSC0_CR = (uint8_t)0x80U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x80U;
+      // OSC1_CR = (uint8_t)0x80U;
+
       /* MCG_C1: CLKS=0,FRDIV=5,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
       MCG_C1 = (uint8_t)0x28U;
       /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
       MCG_C2 = (uint8_t)0x21U;
-      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-      MCG_C11 = (uint8_t)0x03U;
+      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+      MCG_C11 = (uint8_t)0x04U;
       /* MCG_C11: PLLCLKEN1=1 */
       MCG_C11 |= (uint8_t)0x40U;       /* Enable the PLL */
       /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=8 */
@@ -388,8 +437,11 @@ static void Cpu_SetMCGModePBE(uint8_t CLKMode)
       OSC0_CR = (uint8_t)0x80U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x80U;
+      // OSC1_CR = (uint8_t)0x80U;
+
       /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=0,IREFSTEN=0 */
       MCG_C1 = (uint8_t)0xA8U;
       /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
@@ -398,8 +450,8 @@ static void Cpu_SetMCGModePBE(uint8_t CLKMode)
       MCG_C5 = (uint8_t)0x04U;
       /* MCG_C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=8 */
       MCG_C6 = (uint8_t)0x48U;
-      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-      MCG_C11 = (uint8_t)0x03U;
+      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+      MCG_C11 = (uint8_t)0x04U;
       /* MCG_C11: PLLCLKEN1=1 */
       MCG_C11 |= (uint8_t)0x40U;       /* Enable the PLL */
       /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=8 */
@@ -415,8 +467,11 @@ static void Cpu_SetMCGModePBE(uint8_t CLKMode)
       OSC0_CR = (uint8_t)0x00U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x00U;
+      // OSC1_CR = (uint8_t)0x00U;
+
       /* MCG_C1: CLKS=2,FRDIV=5,IREFS=0,IRCLKEN=1,IREFSTEN=0 */
       MCG_C1 = (uint8_t)0xAAU;
       /* MCG_C2: LOCRE0=0,??=0,RANGE0=2,HGO0=0,EREFS0=0,LP=0,IRCS=1 */
@@ -424,13 +479,9 @@ static void Cpu_SetMCGModePBE(uint8_t CLKMode)
       /* MCG_C5: PLLREFSEL0=0,PLLCLKEN0=0,PLLSTEN0=0,??=0,??=0,PRDIV0=4 */
       MCG_C5 = (uint8_t)0x04U;
       /* MCG_C6: LOLIE0=0,PLLS=1,CME0=0,VDIV0=0 */
-      /*
-      ** Trick: do not change MCG_C6 in this mode
-      ** if MCG_C6 = (uint8_t)0x40U: can not change Clock source to 2MHz after 3 times
-      */
-      MCG_C6 = (uint8_t)0x48U;
-      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-      MCG_C11 = (uint8_t)0x03U;
+      MCG_C6 = (uint8_t)0x40U;
+      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+      MCG_C11 = (uint8_t)0x04U;
       /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=0 */
       MCG_C12 = (uint8_t)0x00U;
       while((MCG_S & 0x0CU) != 0x08U) { /* Wait until external reference clock is selected as MCG output */
@@ -459,8 +510,11 @@ static void Cpu_SetMCGModeFBE(uint8_t CLKMode)
       /* Switch to FBE Mode */
       /* OSC0_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
       OSC0_CR = (uint8_t)0x80U;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x80U;
+      // OSC1_CR = (uint8_t)0x80U;
+
       /* MCG_C7: OSCSEL=0 */
       MCG_C7 &= (uint8_t)~(uint8_t)0x01U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
@@ -475,8 +529,8 @@ static void Cpu_SetMCGModeFBE(uint8_t CLKMode)
       MCG_C5 = (uint8_t)0x04U;
       /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=8 */
       MCG_C6 = (uint8_t)0x08U;
-      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-      MCG_C11 = (uint8_t)0x03U;
+      /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+      MCG_C11 = (uint8_t)0x04U;
       /* MCG_C11: PLLCLKEN1=1 */
       MCG_C11 |= (uint8_t)0x40U;       /* Enable the PLL */
       /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=8 */
@@ -490,8 +544,11 @@ static void Cpu_SetMCGModeFBE(uint8_t CLKMode)
       /* Switch to FBE Mode */
       /* OSC0_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
       OSC0_CR = (uint8_t)0x00U;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x00U;
+      // OSC1_CR = (uint8_t)0x00U;
+
       /* MCG_C7: OSCSEL=0 */
       MCG_C7 &= (uint8_t)~(uint8_t)0x01U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
@@ -542,8 +599,11 @@ static void Cpu_SetMCGModeBLPI(uint8_t CLKMode)
   OSC0_CR = (uint8_t)0x00U;            /* 7 */
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x00U;
+      // OSC1_CR = (uint8_t)0x00U;
+
       while((MCG_S & MCG_S_IREFST_MASK) == 0x00U) { /* Check that the source of the FLL reference clock is the internal reference clock. */
       }
       while((MCG_S & MCG_S_IRCST_MASK) == 0x00U) { /* Check that the fast external reference clock is selected. */
@@ -578,16 +638,19 @@ static void Cpu_SetMCGModeFBI(uint8_t CLKMode)
       OSC0_CR = (uint8_t)0x80U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x80U;
+      // OSC1_CR = (uint8_t)0x80U;
+
       /* MCG_C7: OSCSEL=0 */
       MCG_C7 &= (uint8_t)~(uint8_t)0x01U;
       /* MCG_C5: PLLREFSEL0=0,PLLCLKEN0=0,PLLSTEN0=0,??=0,??=0,PRDIV0=4 */
       MCG_C5 = (uint8_t)0x04U;
   /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=8 */
   MCG_C6 = (uint8_t)0x08U;             /* 7 */
-  /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-  MCG_C11 = (uint8_t)0x03U;            /* 7 */
+  /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+  MCG_C11 = (uint8_t)0x04U;            /* 7 */
       /* MCG_C11: PLLCLKEN1=1 */
       MCG_C11 |= (uint8_t)0x40U;       /* Enable the PLL */
   /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=8 */
@@ -609,8 +672,11 @@ static void Cpu_SetMCGModeFBI(uint8_t CLKMode)
       OSC0_CR = (uint8_t)0x00U;
       /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
       MCG_C10 = (uint8_t)0x2CU;
+
+      //Buem
       /* OSC1_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-      OSC1_CR = (uint8_t)0x00U;
+      // OSC1_CR = (uint8_t)0x00U;
+
       /* MCG_C7: OSCSEL=0 */
       MCG_C7 &= (uint8_t)~(uint8_t)0x01U;
       /* MCG_C5: PLLREFSEL0=0,PLLCLKEN0=0,PLLSTEN0=0,??=0,??=0,PRDIV0=0 */
@@ -906,65 +972,84 @@ LDD_TError Cpu_SetOperationMode(LDD_TDriverOperationMode OperationMode, LDD_TCal
 **     Description :
 **         Initializes the whole system like timing, external bus, etc.
 **         This method is internal. It is used by Processor Expert only.
+**     Modifiziert für I-300 M. Bürki 03.07.2013
 ** ===================================================================
 */
 
 /*** !!! Here you can place your own code using property "User data declarations" on the build options tab. !!! ***/
 
+#pragma optimize=none  // Damit die For-Schleife nicht weg-optimiert wird.
 void __pe_initialize_hardware(void)
 {
+int cnt;
+
   _bsp_watchdog_disable();
 
-#if MQX_ENABLE_LOW_POWER
-    /* Reset from LLWU wake up source */
-    if (_lpm_get_reset_source() == MQX_RESET_SOURCE_LLWU)
-    {
-        PMC_REGSC |= PMC_REGSC_ACKISO_MASK;
-    }
-#endif
+  PE_low_level_init(); //Buem 02.07.2013
+
+  for (cnt=0; cnt<400000; cnt++);  // Delay, damit externer Clock Zeit hat, um stabil zu werden. M. Suter, 12.03.2013
+
   /*** !!! Here you can place your own code before PE initialization using property "User code before PE initialization" on the build options tab. !!! ***/
 
   /*** ### MK70FN1M0VMJ12 "Cpu" init code ... ***/
   /*** PE initialization code after reset ***/
+
+  // RTC-Oszillator nicht vorhanden! Buem 02.07.2013
   /* SIM_SCGC6: RTC=1 */
-  SIM_SCGC6 |= (uint32_t)0x20000000UL;
-  if ((RTC_CR & RTC_CR_OSCE_MASK) == 0u) { /* Only if the OSCILLATOR is not already enabled */
+  //  SIM_SCGC6 |= (uint32_t)0x20000000UL;
+  //if ((RTC_CR & RTC_CR_OSCE_MASK) == 0u) { /* Only if the OSCILLATOR is not already enabled */
     /* RTC_CR: SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-    RTC_CR &= (uint32_t)~0x3C00UL;
+  //  RTC_CR &= (uint32_t)~0x3C00UL;
     /* RTC_CR: OSCE=1 */
-    RTC_CR |= (uint32_t)0x0100UL;
+  //  RTC_CR |= (uint32_t)0x0100UL;
     /* RTC_CR: CLKO=0 */
-    RTC_CR &= (uint32_t)~0x0200UL;
-  }
+  //  RTC_CR &= (uint32_t)~0x0200UL;
+  //}
 
   /* System clock initialization */
+
   /* SIM_SCGC5: PORTE=1,PORTC=1,PORTA=1 */
-  SIM_SCGC5 |= (uint32_t)0x2A00UL;     /* Enable clock gate for ports to enable pin routing */
+  //SIM_SCGC5 |= (uint32_t)0x2A00UL;     /* Enable clock gate for ports to enable pin routing */
+  /* SIM_SCGC5: PORTA=1 Buem 02.07.2013*/
+  SIM_SCGC5 |= (uint32_t)0x0200UL;     /* Enable clock gate for ports to enable pin routing */
+
   if ( *((uint8_t*) 0x03FFU) != 0xFFU) {
     MCG_C3 = *((uint8_t*) 0x03FFU);
     MCG_C4 = (MCG_C4 & 0xE0U) | ((*((uint8_t*) 0x03FEU)) & 0x1FU);
   }
+
   /* SIM_CLKDIV1: OUTDIV1=0,OUTDIV2=1,OUTDIV3=2,OUTDIV4=5,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0,??=0 */
   SIM_CLKDIV1 = (uint32_t)0x01250000UL; /* Update system prescalers */
   /* SIM_CLKDIV4: NFCDIV=7 */
   SIM_CLKDIV4 |=  SIM_CLKDIV4_NFCDIV(7);
   /* SIM_SOPT2: PLLFLLSEL=1 */
   SIM_SOPT2 = (uint32_t)((SIM_SOPT2 & (uint32_t)~0x00020000UL) | (uint32_t)0x00010000UL); /* Select PLL 0 as a clock source for various peripherals */
+
+  // Achtung: Kein 32K Oszillator!
   /* SIM_SOPT1: OSC32KSEL=1 */
   SIM_SOPT1 |= (uint32_t)0x00080000UL; /* RTC oscillator drives 32 kHz clock for various peripherals */
+
+  // OSC1 wird nicht benötigt
   /* SIM_SCGC1: OSC1=1 */
-  SIM_SCGC1 |= (uint32_t)0x20UL;
+  // SIM_SCGC1 |= (uint32_t)0x20UL;
+
   /* PORTA_PCR18: ISF=0,MUX=0 */
   PORTA_PCR18 &= (uint32_t)~0x01000700UL;
+
+  // Kein 32K Oszillator! Buem 02.07.2013
   /* PORTE_PCR24: ISF=0,MUX=0 */
-  PORTE_PCR24 &= (uint32_t)~0x01000700UL;
+  //PORTE_PCR24 &= (uint32_t)~0x01000700UL;
   /* PORTE_PCR25: ISF=0,MUX=0 */
-  PORTE_PCR25 &= (uint32_t)~0x01000700UL;
+  //PORTE_PCR25 &= (uint32_t)~0x01000700UL;
+
   /* Switch to FBE Mode */
   /* OSC0_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
   OSC0_CR = (uint8_t)0x80U;
-  /* OSC1_CR: ERCLKEN=1,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
-  OSC1_CR = (uint8_t)0x80U;
+
+  // OSC1 wird nicht benötigt
+  /* OSC1_CR: ERCLKEN=0,??=0,EREFSTEN=0,??=0,SC2P=0,SC4P=0,SC8P=0,SC16P=0 */
+  //OSC1_CR = (uint8_t)0x00U;
+
   /* MCG_C7: OSCSEL=0 */
   MCG_C7 &= (uint8_t)~(uint8_t)0x01U;
   /* MCG_C10: LOCRE2=0,??=0,RANGE1=2,HGO1=1,EREFS1=1,??=0,??=0 */
@@ -979,12 +1064,17 @@ void __pe_initialize_hardware(void)
   MCG_C5 = (uint8_t)0x04U;
   /* MCG_C6: LOLIE0=0,PLLS=0,CME0=0,VDIV0=8 */
   MCG_C6 = (uint8_t)0x08U;
-  /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=3 */
-  MCG_C11 = (uint8_t)0x03U;
+  /* MCG_C11: PLLREFSEL1=0,PLLCLKEN1=0,PLLSTEN1=0,PLLCS=0,??=0,PRDIV1=4 */
+  MCG_C11 = (uint8_t)0x04U;
   /* MCG_C11: PLLCLKEN1=1 */
   MCG_C11 |= (uint8_t)0x40U;           /* Enable the PLL */
+
+  // PLL1 auf 150MHz Buem 02.07.2013
+  /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=14 */
+  MCG_C12 = (uint8_t)0x0EU;
   /* MCG_C12: LOLIE1=0,??=0,CME2=0,VDIV1=8 */
-  MCG_C12 = (uint8_t)0x08U;
+  //MCG_C12 = (uint8_t)0x08U;
+
   while((MCG_S & MCG_S_IREFST_MASK) != 0x00U) { /* Check that the source of the FLL reference clock is the external reference clock. */
   }
   while((MCG_S & 0x0CU) != 0x08U) {    /* Wait until external reference clock is selected as MCG output */
@@ -1005,6 +1095,15 @@ void __pe_initialize_hardware(void)
   MCG_C6 |= (uint8_t)0x20U;            /* Enable the clock monitor */
   /*** End of PE initialization code after reset ***/
 
+  // OSC1 abschalten
+  // MCG_C10: EREFS1=0,HGO1=0,RANGE1=2,LOCRE2=0
+  MCG_C10 = 0x20U;
+
+  //PER_RST aktivieren -> Clockgate PortA ist bereits eingeschaltet
+  PORT_PCR_REG(PORTA_BASE_PTR, 25) = PORT_PCR_MUX(1); // define ALT Func 1
+  GPIOA_PDDR  |= 1 << 25;  // Configure pin als Ausgang
+  GPIOA_PSOR  |= 1 << 25;  // Setze Ausgang auf 1
+
   /*** !!! Here you can place your own code after PE initialization using property "User code after PE initialization" on the build options tab. !!! ***/
 
 }
@@ -1020,45 +1119,52 @@ void __pe_initialize_hardware(void)
 **         The method is called automatically as a part of the
 **         application initialization code.
 **         This method is internal. It is used by Processor Expert only.
+**     Modifiziert für I-300 M. Bürki 03.07.2013
 ** ===================================================================
 */
 void PE_low_level_init(void)
 {
-      /* Initialization of the SIM module */
-  /* SIM_SOPT2: CMTUARTPAD=0 */
-  SIM_SOPT2 &= (uint32_t)~0x0800UL;
-  /* PORTA_PCR4: ISF=0,MUX=7 */
-  PORTA_PCR4 = (uint32_t)((PORTA_PCR4 & (uint32_t)~0x01000000UL) | (uint32_t)0x0700UL);
-        /* Initialization of the RCM module */
-  /* RCM_RPFW: RSTFLTSEL=0 */
-  RCM_RPFW &= (uint8_t)~(uint8_t)0x1FU;
-  /* RCM_RPFC: RSTFLTSS=0,RSTFLTSRW=0 */
-  RCM_RPFC &= (uint8_t)~(uint8_t)0x07U;
-      /* Initialization of the PMC module */
-  /* PMC_LVDSC1: LVDACK=1,LVDIE=0,LVDRE=1,LVDV=0 */
-  PMC_LVDSC1 = (uint8_t)((PMC_LVDSC1 & (uint8_t)~(uint8_t)0x23U) | (uint8_t)0x50U);
-  /* PMC_LVDSC2: LVWACK=1,LVWIE=0,LVWV=0 */
-  PMC_LVDSC2 = (uint8_t)((PMC_LVDSC2 & (uint8_t)~(uint8_t)0x23U) | (uint8_t)0x40U);
-  /* PMC_REGSC: BGEN=0,ACKISO=0,BGBE=0 */
-  PMC_REGSC &= (uint8_t)~(uint8_t)0x19U;
-        /* Initialization of the LLWU module */
-  /* LLWU_PE1: WUPE3=0,WUPE2=0,WUPE1=0,WUPE0=0 */
-  LLWU_PE1 = (uint8_t)0x00U;
-  /* LLWU_PE2: WUPE7=0,WUPE6=0,WUPE5=0,WUPE4=0 */
-  LLWU_PE2 = (uint8_t)0x00U;
-  /* LLWU_PE3: WUPE11=0,WUPE10=0,WUPE9=0,WUPE8=0 */
-  LLWU_PE3 = (uint8_t)0x00U;
-  /* LLWU_PE4: WUPE15=0,WUPE14=0,WUPE13=0,WUPE12=0 */
-  LLWU_PE4 = (uint8_t)0x00U;
-  /* LLWU_ME: WUME7=0,WUME6=0,WUME5=0,WUME4=0,WUME3=0,WUME2=0,WUME1=0,WUME0=1 */
-  LLWU_ME = (uint8_t)0x01U;
-  /* LLWU_FILT1: FILTF=1,FILTE=0,??=0,FILTSEL=0 */
-  LLWU_FILT1 = (uint8_t)0x80U;
-  /* LLWU_FILT2: FILTF=1,FILTE=0,??=0,FILTSEL=0 */
-  LLWU_FILT2 = (uint8_t)0x80U;
-  /* LLWU_RST: ??=0,??=0,??=0,??=0,??=0,??=0,LLRSTE=0,RSTFILT=0 */
-  LLWU_RST = (uint8_t)0x00U;
+    /* Powerup Sequenz: Buem 02.07.2013 */
+    PMC_LVDSC1 = PMC_LVDSC1_LVDRE_MASK + PMC_LVDSC1_LVDV(1); // Resetpegel auf High Range, 2.48V bis 2.64V
+    PMC_LVDSC2 = PMC_LVDSC2_LVWV(1);                         // Warnpegel auf Mid 1, 2.72V bis 2.88V
+    //PMC_LVDSC2 = PMC_LVDSC2_LVWV(2);                       // Warnpegel auf Mid 2, 2.82V bis 2.98V
+
+    while (PMC_LVDSC2 & PMC_LVDSC2_LVWF_MASK)
+    {
+       PMC_LVDSC2 |= PMC_LVDSC2_LVWACK_MASK;
+    }
 
+    RCM_RPFW = 0x1f;   // Resetfilter 5ms
+    RCM_RPFC = 2;
+    PMC_LVDSC1  = PMC_LVDSC1_LVDACK_MASK +
+                  PMC_LVDSC1_LVDRE_MASK  +
+                  PMC_LVDSC1_LVDV(1);
+
+    /* Initialization of the LLWU module */
+    /* LLWU_PE1: WUPE3=0,WUPE2=0,WUPE1=0,WUPE0=0 */
+  //LLWU_PE1 = (uint8_t)0x00U;
+    /* LLWU_PE2: WUPE7=0,WUPE6=0,WUPE5=0,WUPE4=0 */
+  //LLWU_PE2 = (uint8_t)0x00U;
+    /* LLWU_PE3: WUPE11=0,WUPE10=0,WUPE9=0,WUPE8=0 */
+  //LLWU_PE3 = (uint8_t)0x00U;
+    /* LLWU_PE4: WUPE15=0,WUPE14=0,WUPE13=0,WUPE12=0 */
+  //LLWU_PE4 = (uint8_t)0x00U;
+    /* LLWU_ME: WUME7=0,WUME6=0,WUME5=0,WUME4=0,WUME3=0,WUME2=0,WUME1=0,WUME0=1 */
+  //LLWU_ME = (uint8_t)0x01U;
+    /* LLWU_FILT1: FILTF=1,FILTE=0,??=0,FILTSEL=0 */
+  //LLWU_FILT1 = (uint8_t)0x80U;
+    /* LLWU_FILT2: FILTF=1,FILTE=0,??=0,FILTSEL=0 */
+  //LLWU_FILT2 = (uint8_t)0x80U;
+    /* LLWU_RST: ??=0,??=0,??=0,??=0,??=0,??=0,LLRSTE=0,RSTFILT=0 */
+  //LLWU_RST = (uint8_t)0x00U;
+
+  // Keine Lowpower-Modes schaltbar
+    /* SMC_PMPROT: ??=0,??=0,AVLP=1,??=0,ALLS=1,??=0,AVLLS=0,??=0 */
+  //SMC_PMPROT = (uint8_t)0x28U;         /* Setup Power mode protection register */
+    SMC_PMPROT =0;
+
+  // Flexbus Clockgate abschalten
+    SIM_SCGC7=0x06U;
 }
 
 
diff --git a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_gpio.c b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_gpio.c
index 9b79e36..924ab99 100644
--- a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_gpio.c
+++ b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_gpio.c
@@ -702,20 +702,20 @@ _mqx_int _bsp_esdhc_io_init
 )
 {
     SIM_MemMapPtr   sim  = SIM_BASE_PTR;
-    PORT_MemMapPtr  pctl;
+    //PORT_MemMapPtr  pctl;
 
     switch (dev_num)
     {
         case 0:
             /* Configure GPIO for SDHC peripheral function */
-            pctl = (PORT_MemMapPtr)PORTE_BASE_PTR;
-
-            pctl->PCR[0] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
-            pctl->PCR[1] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
-            pctl->PCR[2] = value & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
-            pctl->PCR[3] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
-            pctl->PCR[4] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
-            pctl->PCR[5] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
+            //FIT
+            //pctl = (PORT_MemMapPtr)PORTE_BASE_PTR;
+            //pctl->PCR[0] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
+            //pctl->PCR[1] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
+            //pctl->PCR[2] = value & (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
+            //pctl->PCR[3] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
+            //pctl->PCR[4] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
+            //pctl->PCR[5] = value & (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
 
             /* Enable clock gate to SDHC module */
             sim->SCGC3 |= SIM_SCGC3_ESDHC_MASK;
@@ -759,7 +759,7 @@ _mqx_int _bsp_flexcan_io_init
 
             /* Enable clock gate to FlexCAN 0 module */
             sim->SCGC6 |= SIM_SCGC6_FLEXCAN0_MASK;
-            
+
             /* Select the bus clock as CAN engine clock source */
             can = (CAN_MemMapPtr)CAN0_BASE_PTR;
             can->CTRL1 |= CAN_CTRL1_CLKSRC_MASK;
@@ -925,9 +925,9 @@ static _mqx_int _bsp_usb_io_init
         //Enable clock to the module
         SIM_SCGC6 |= SIM_SCGC6_USBHS_MASK;
 
-        SIM_CLKDIV2 |= SIM_CLKDIV2_USBHSFRAC_MASK | SIM_CLKDIV2_USBHSDIV_MASK; // Divide reference clock to obtain 60MHz 
-        SIM_SOPT2 &= ~SIM_SOPT2_USBHSRC_MASK;  // MCGPLLCLK for the USB 60MHz CLKC source 
-        SIM_SOPT2 |= SIM_SOPT2_USBHSRC(1);     // MCGPLLCLK for the USB 60MHz CLKC source 
+        SIM_CLKDIV2 |= SIM_CLKDIV2_USBHSFRAC_MASK | SIM_CLKDIV2_USBHSDIV_MASK; // Divide reference clock to obtain 60MHz
+        SIM_SOPT2 &= ~SIM_SOPT2_USBHSRC_MASK;  // MCGPLLCLK for the USB 60MHz CLKC source
+        SIM_SOPT2 |= SIM_SOPT2_USBHSRC(1);     // MCGPLLCLK for the USB 60MHz CLKC source
 
         //Select external clock for USBH controller
         PORTA_PCR7 = PORT_PCR_MUX(2);   //ULPI DIR
@@ -942,7 +942,7 @@ static _mqx_int _bsp_usb_io_init
         PORTA_PCR29 = PORT_PCR_MUX(2);  //ULPI DATA7
         PORTA_PCR6 = PORT_PCR_MUX(2);   //ULPI CLK
         PORTA_PCR9 = PORT_PCR_MUX(2);   //ULPI STP
-        
+
         /*
          *If we can't control when to provide the power to ULPI PHY and when to enable the
          * ULPI PHY clock a PHY RESET should be done after ULPI PHY initialization to make the
@@ -1023,21 +1023,29 @@ _mqx_int _bsp_usb_host_io_init
 *    This function performs BSP-specific initialization related to GPIO
 *
 *END*----------------------------------------------------------------------*/
-
-_mqx_int _bsp_gpio_io_init
-(
-    void
-)
+_mqx_int _bsp_gpio_io_init(void)
 {
-    /* Enable clock gating to all ports */
-    SIM_SCGC5 |=   SIM_SCGC5_PORTA_MASK \
+   // Enable clock gating to all ports
+   SIM_SCGC5 |=   SIM_SCGC5_PORTA_MASK \
                  | SIM_SCGC5_PORTB_MASK \
                  | SIM_SCGC5_PORTC_MASK \
                  | SIM_SCGC5_PORTD_MASK \
                  | SIM_SCGC5_PORTE_MASK \
                  | SIM_SCGC5_PORTF_MASK;
 
-    return MQX_OK;
+   PORT_MemMapPtr  pctl;
+
+   //FIT
+   // Configure GPIO for SDHC peripheral function
+   pctl = (PORT_MemMapPtr)PORTE_BASE_PTR;
+   pctl->PCR[0] = (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D1  */
+   pctl->PCR[1] = (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D0  */
+   pctl->PCR[2] = (PORT_PCR_MUX(4) | PORT_PCR_DSE_MASK);                                          /* ESDHC.CLK */
+   pctl->PCR[3] = (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.CMD */
+   pctl->PCR[4] = (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D3  */
+   pctl->PCR[5] = (PORT_PCR_MUX(4) | PORT_PCR_PS_MASK | PORT_PCR_PE_MASK | PORT_PCR_DSE_MASK);    /* ESDHC.D2  */
+
+   return MQX_OK;
 }
 
 /*FUNCTION*-------------------------------------------------------------------
@@ -1126,7 +1134,7 @@ _mqx_int _bsp_nandflash_io_init
 }
 
 /*FUNCTION*-------------------------------------------------------------------
-* 
+*
 * Function Name    : _bsp_ftfx_io_init
 * Returned Value   : 0 for success, -1 for failure
 * Comments         :
@@ -1136,7 +1144,7 @@ _mqx_int _bsp_nandflash_io_init
 _mqx_int _bsp_ftfx_io_init
 (
     _mqx_uint device_index
-) 
+)
 {
     SIM_MemMapPtr sim = SIM_BASE_PTR;
 
@@ -1163,9 +1171,9 @@ _mqx_int _bsp_tss_io_init
 )
 {
     SIM_MemMapPtr sim = SIM_BASE_PTR;
-    
+
     sim->SCGC5 |= SIM_SCGC5_TSI_MASK;   /* TSI clock enablement */
-    
+
     /* Set Electrodes for TSI function */
     PORTB_PCR0 = PORT_PCR_MUX(0);
     PORTB_PCR1 = PORT_PCR_MUX(0);
@@ -1193,27 +1201,27 @@ _mqx_int _bsp_sai_io_init
         case 0:
             /* Enable system clock to the I2S module */
             SIM_SCGC6 |= SIM_SCGC6_SAI0_MASK;                   /* Enable SAI0 clock gate control & DMAMUX0 clock gate controlntrol */
-            
+
             /* Enable SSI pins */
             PORTE_PCR6 |= PORT_PCR_MUX(0x04);                   /* Configure port for MCLK output */
-            
+
             /* GPIO for SSI0_BLCK */
             PORTE_PCR12 |= PORT_PCR_MUX(0x04);                  /* Configure Port for TX Bit Clock */
-            
+
             /* GPIO for SSI0_FS */
             PORTE_PCR11 |= PORT_PCR_MUX(0x04);                  /* Configure port for TX Frame Sync */
-            
+
             /* GPIO for SSI0_XD */
             PORTE_PCR10 |= PORT_PCR_MUX(0x04);                  /* Configure port for TX Data */
             PORTE_PCR7 |= PORT_PCR_MUX(0x04);                   /* Configure port for RX Data */
             break;
-            
+
         case 1:
             break;
         default:
             break;
     }
-    
+
     return MQX_OK;
 }
 
@@ -1236,7 +1244,7 @@ _mqx_int _bsp_serial_irda_tx_init(uint32_t device_index, bool enable)
     {
         return -1;
     }
-    if (TRUE == enable) 
+    if (TRUE == enable)
     {
         /* Enable drive strength for IrDA TX pin (PTD7)*/
         sim->SOPT2 |= SIM_SOPT2_CMTUARTPAD_MASK;
@@ -1244,8 +1252,8 @@ _mqx_int _bsp_serial_irda_tx_init(uint32_t device_index, bool enable)
         /* PTD7 as UART TX function (Alt.3) + drive strength */
         pctl = (PORT_MemMapPtr) PORTD_BASE_PTR;
         pctl->PCR[7] = PORT_PCR_MUX(3) | PORT_PCR_DSE_MASK;
-    } 
-    else 
+    }
+    else
     {
         return MQX_OK;
     }
@@ -1263,13 +1271,13 @@ _mqx_int _bsp_serial_irda_tx_init(uint32_t device_index, bool enable)
 
 _mqx_int _bsp_serial_irda_rx_init(uint32_t device_index, bool enable)
 {
-    if (TRUE == enable) 
+    if (TRUE == enable)
     {
-        /* hardware does not support this feature. The IrDA receiver connected 
+        /* hardware does not support this feature. The IrDA receiver connected
         ** to CMR2_IN3 but the UART does not support slecting source from CMP2 out put
         */
         return -1;
-    } 
+    }
     return MQX_OK;
 }
 /* EOF */
diff --git a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_hw.c b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_hw.c
index b9f3119..a0092eb 100644
--- a/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_hw.c
+++ b/externals/MQX_4_1/mqx/source/bsp/twrk70f120m/init_hw.c
@@ -1,29 +1,36 @@
-/*HEADER**********************************************************************
+/**HEADER***********************************************************************
 *
-* Copyright 2011 Freescale Semiconductor, Inc.
+* Copyright (c) 2011 Freescale Semiconductor;
+* All Rights Reserved
 *
-* This software is owned or controlled by Freescale Semiconductor.
-* Use of this software is governed by the Freescale MQX RTOS License
-* distributed with this Material.
-* See the MQX_RTOS_LICENSE file distributed for more details.
+********************************************************************************
 *
-* Brief License Summary:
-* This software is provided in source form for you to use free of charge,
-* but it is not open source software. You are allowed to use this software
-* but you cannot redistribute it or derivative works of it in source form.
-* The software may be used only in connection with a product containing
-* a Freescale microprocessor, microcontroller, or digital signal processor.
-* See license agreement file for full license terms including other
-* restrictions.
-*****************************************************************************
+* THIS SOFTWARE IS PROVIDED BY FREESCALE "AS IS" AND ANY EXPRESSED OR
+* IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+* OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+* IN NO EVENT SHALL FREESCALE OR ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+* INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+* SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+* STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+* IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*
+********************************************************************************
+*
+* $FileName: init_hw.c$
+* $Version : 3.8.5.0$
+* $Date    : Jun-6-2012$
 *
 * Comments:
 *
 *   This file contains flash boot code to initialize chip selects,
 *   disable the watchdog timer and initialize the PLL.
 *
+* Modifiziert für I-300 M. Bürki 02.07.2013
 *
-*END************************************************************************/
+*END***************************************************************************/
 
 #include "mqx.h"
 #include "bsp.h"
@@ -39,7 +46,7 @@
 *
 *END*-------------------------------------------------------------------------*/
 
-void _bsp_watchdog_disable(void) 
+void _bsp_watchdog_disable(void)
 {
     WDOG_MemMapPtr reg = WDOG_BASE_PTR;
 
@@ -57,14 +64,14 @@ void _bsp_watchdog_disable(void)
 }
 
 /*FUNCTION*---------------------------------------------------------------------
-* 
+*
 * Function Name    : _bsp_flexbus_setup
 * Returned Value   :  none
 * Comments         :
 *    Setup FlexBus pins for early MRAM operation
 *
 *END*-------------------------------------------------------------------------*/
-static void _bsp_flexbus_setup (void) 
+static void _bsp_flexbus_setup (void)
 {
     #define ALT5                    0x05
     #define OFF_CHIP_ACCESS_ALLOW   3
@@ -88,7 +95,7 @@ static void _bsp_flexbus_setup (void)
     pctl->PCR[21] = PORT_PCR_MUX(ALT5); /* FB_AD30 */
     pctl->PCR[22] = PORT_PCR_MUX(ALT5); /* FB_AD29 */
     pctl->PCR[23] = PORT_PCR_MUX(ALT5); /* FB_AD28 */
-    
+
     pctl = (PORT_MemMapPtr)PORTC_BASE_PTR;
     pctl->PCR[0] = PORT_PCR_MUX(ALT5); /* FB_AD14 */
     pctl->PCR[1] = PORT_PCR_MUX(ALT5); /* FB_AD13 */
@@ -106,7 +113,7 @@ static void _bsp_flexbus_setup (void)
     pctl->PCR[13] = PORT_PCR_MUX(ALT5); /* FB_AD26 */
     pctl->PCR[14] = PORT_PCR_MUX(ALT5); /* FB_AD25 */
     pctl->PCR[15] = PORT_PCR_MUX(ALT5); /* FB_AD24 */
-    
+
     pctl = (PORT_MemMapPtr)PORTD_BASE_PTR;
     pctl->PCR[0] = PORT_PCR_MUX(ALT5); /* FB_ALE */
     pctl->PCR[1] = PORT_PCR_MUX(ALT5); /* FB_CS0_b */
@@ -136,10 +143,10 @@ static void _bsp_flexbus_mram_setup (const uint32_t base_address)
     /* CS0 base address */
     fb_ptr->CS[0].CSAR = base_address;
     /* CS0 control (8bit data, 1 wait state) */
-    fb_ptr->CS[0].CSCR = FB_CSCR_AA_MASK | 
-                         FB_CSCR_WS(2)   | 
-                         FB_CSCR_PS(1)   | 
-                         FB_CSCR_BEM_MASK; 
+    fb_ptr->CS[0].CSCR = FB_CSCR_AA_MASK |
+                         FB_CSCR_WS(2)   |
+                         FB_CSCR_PS(1)   |
+                         FB_CSCR_BEM_MASK;
 
     /* CS0 address mask and enable */
     fb_ptr->CS[0].CSMR = FB_CSMR_BAM(0x07) | FB_CSMR_V_MASK;
@@ -168,7 +175,7 @@ void _bsp_flexbus_lcd_setup (const uint32_t base_address)
      * The address range is set to 128K because
      * the DC signal is connected on address wire
      */
-    fb_ptr->CS[0].CSMR = FB_CSMR_BAM(1) | FB_CSMR_V_MASK;      
+    fb_ptr->CS[0].CSMR = FB_CSMR_BAM(1) | FB_CSMR_V_MASK;
 }
 
 /*FUNCTION*---------------------------------------------------------------------
@@ -184,7 +191,7 @@ void _bsp_flexbus_pccard_setup (const uint32_t base_address)
     FB_MemMapPtr fb_ptr = FB_BASE_PTR;
 
     /* invalidate CS configuration first */
-    fb_ptr->CS[1].CSMR = 0; 
+    fb_ptr->CS[1].CSMR = 0;
 
     /* Enable external PCCARD mapped on CS1 */
     fb_ptr->CS[1].CSAR = base_address;
@@ -192,10 +199,10 @@ void _bsp_flexbus_pccard_setup (const uint32_t base_address)
     fb_ptr->CS[1].CSCR = FB_CSCR_AA_MASK |
                          FB_CSCR_WS(11) |
                          FB_CSCR_PS(1) |
-                         FB_CSCR_BEM_MASK; 
+                         FB_CSCR_BEM_MASK;
 
     /* CS1 address mask (64 KB) and enable */
-    fb_ptr->CS[1].CSMR = FB_CSMR_BAM(0) | FB_CSMR_V_MASK; 
+    fb_ptr->CS[1].CSMR = FB_CSMR_BAM(0) | FB_CSMR_V_MASK;
 }
 
 /*FUNCTION*---------------------------------------------------------------------
@@ -206,7 +213,7 @@ void _bsp_flexbus_pccard_setup (const uint32_t base_address)
 *    SDRAM initailization routine.
 *
 *END*-------------------------------------------------------------------------*/
-void _bsp_ddr2_setup (void)
+void _bsp_ddr2_setupUNUSED (void)
 {
     SIM_MemMapPtr   sim = SIM_BASE_PTR;
     DDR_MemMapPtr   ddr = DDR_BASE_PTR;
@@ -214,13 +221,13 @@ void _bsp_ddr2_setup (void)
 
     /* Enable DDR controller clock */
     sim->SCGC3 |= SIM_SCGC3_DDR_MASK;
-    
+
     /* Enable DDR pads and set slew rate */
     sim->MCR |= 0xC4;   /* bits were left out of the manual so there isn't a macro right now */
 
     ddr->RCR |= DDR_RCR_RST_MASK;
 
-    * (volatile uint32_t *)(0x400Ae1ac) = 0x01030203;
+    //* (vuint32_t *)(0x400Ae1ac) = 0x01030203;
 
     /* TC's init */
     ddr->CR00 = 0x00000400;
@@ -267,8 +274,8 @@ void _bsp_ddr2_setup (void)
     ddr->CR50 = 0x00000064;
     ddr->CR52 = 0x02000602;
     ddr->CR53 = 0x03c80000;
-    ddr->CR54 = 0x03c803c8;
-    ddr->CR55 = 0x03c803c8;
+    ddr->CR53 = 0x03c803c8;
+    ddr->CR53 = 0x03c803c8;
     ddr->CR56 = 0x020303c8;
     ddr->CR57 = 0x01010002;
 
@@ -279,21 +286,114 @@ void _bsp_ddr2_setup (void)
     while ((ddr->CR30 & 0x400) != 0x400) {
     }
 
-    mcm->CR |= MCM_CR_DDRSIZE(1);  
+    mcm->CR |= MCM_CR_DDRSIZE(1);
+}
+
+/*FUNCTION*---------------------------------------------------------------------
+*
+* Function Name    : _bsp_ddr_setup
+* Returned Value   :
+* Comments         :
+*    SDRAM initailization routine.
+
+*    Michael Suter 27.05.2013
+*    Diese Prozedur tritt anstelle von _bsp_ddr_setup2
+     Grund: _bsp_ddr2_setup ist für das tower-Board twrk70fl120m geschrieben
+     _bsp_ddr_setup ist für das Büchi I-300 Board geschrieben, es enthält das
+     RAM IS43DR16160.
+
+*END*-------------------------------------------------------------------------*/
+int _bsp_ddr_setup (void)
+{
+	if ((SIM_SCGC3 & SIM_SCGC3_DDR_MASK) != SIM_SCGC3_DDR_MASK)
+	{
+		// Enable DDR clock gate
+		SIM_SCGC3 |= SIM_SCGC3_DDR_MASK;
+	}
+	else
+	{
+		// Check to if the DRAMC is already initialized
+		if ((DDR_CR00 & 1) == 1)
+			return 1;
+	}
+
+	// Setup drive strength & enable IO pad
+	SIM_MCR &= 0xFFFFFF00;
+	SIM_MCR |= 0x00000044;
+
+	// Setup IO pad ODT, 700mV seperation & spare dly ctrl
+	DDR_PAD_CTRL = 0x00030203;
+
+	SIM_MCR |= 0x100;	// DDR RCR reset
+	SIM_MCR &= ~0x100;	// DDR RCR out of reset
+
+	DDR_CR00 = 0x00000400;	// DDRCLS, start
+	DDR_CR02 = 0x02007530;	// initaref, tinit
+	DDR_CR03 = 0x02020707;	// tccd, wrlat, latgate, latlin
+	DDR_CR04 = 0x06090202;	// trasmin, trc, trrd, tbint
+	DDR_CR05 = 0x02020302;	// tmrd, trtp, trp, twtr
+	DDR_CR06 = 0x00290402;	// intwbr, trasmax, tmod
+	DDR_CR07 = 0x01010303;	// ccapen, ap, tckesr, clkpw
+	DDR_CR08 = 0x06030301;	// tdal, twr, trasdi, tras
+	DDR_CR09 = 0x020000c8;	// bstlen, nocmd, tdll
+	DDR_CR10 = 0x03000006;	// trpab, tcpd, tfaw
+	DDR_CR11 = 0x01000000;	// trefen, arefmode, aref, regdimm
+	DDR_CR12 = 0x048a000c;	// tref, trfc
+	DDR_CR13 = 0x00000005;	// pd, trefint
+	DDR_CR14 = 0x001e0003;	// txsr, tpdex
+	DDR_CR15 = 0x0000000d;	// puref, sref, txsnr
+	DDR_CR16 = 0x00000001;	// lpctrl, clkdly, qkref
+	DDR_CR20 = 0x00030300;	// cksrx, cksre, lpre
+	DDR_CR21 = 0x24020432;	// mr1dat0, mr0dat0
+	DDR_CR25 = 0x0a020300;	// aprebit, colsiz, addpins, bnk8
+	DDR_CR26 = 0x0101ffff;	// bnkspt, addcol, cmdage, agecnt
+	DDR_CR27 = 0x01010101;	// swpen, rwen, prien, plen
+	DDR_CR28 = 0x00000001;	// cmdlatr, bigend, reduc, csmap
+	DDR_CR30 = 0x00000001;	// intack, rsyncrf
+	DDR_CR34 = 0x00000101;	// odtwrcs, odtrdcs
+	DDR_CR37 = 0x00000200;	// w2wsame, w2rsame, r2wsame, r2rsame
+	DDR_CR38 = 0x00200000;	// p0wrcnt, pupcs, pdncs
+	DDR_CR39 = 0x01010020;	// wp0, rp0, p0rdcnt
+	DDR_CR40 = 0x00002000;	// p1wrcnt, p0typ
+	DDR_CR41 = 0x00000020;	// wp1, rp1, p1rdcnt
+	DDR_CR42 = 0x00002000;	// p2wrcnt, p1typ
+	DDR_CR43 = 0x02020020;	// wp2, rp2, p2rdcnt
+	DDR_CR45 = 0x00070b0f;	// p0pri3, p0pri2, p0pri1, p0pri0
+	DDR_CR46 = 0x1f004001;	// p1pri0, p0prirlx, p0ord
+	DDR_CR47 = 0x00000e16;	// p1ord, p1pri3, p1pri2, p1pri1
+	DDR_CR48 = 0x0b0f0040;	// p2pri1, p2pri0, p1prirlx
+	DDR_CR49 = 0x00020007;	// p2ord, p2pri3, p2pri2
+	DDR_CR50 = 0x00000040;	// p2prirlx
+	DDR_CR52 = 0x02000602;	// rddtenbas, phyrdlat, phywrltbs
+	DDR_CR53 = 0x048a0000;	// ctrlupdmx, clkdiscs
+	DDR_CR56 = 0x02030000;	// wrlatadj, rdlatadj, phyupdresp
+	DDR_CR57 = 0x01010002;	// odtalten, clkendly, clkdisdly, cmddly
+
+	DDR_CR00 |= 1;	// DDRCLS, start
+
+	while ((DDR_CR30 & 0x400) != 0x400);
+
+	// Setup memory address translation
+	MCM_CR |= MCM_CR_DDRSIZE(0);
+
+	return 1;
 }
 
+////////////////////////////////////////////////////////////////////////////////
+
+
+
 /*FUNCTION*---------------------------------------------------------------------
 *
 * Function Name    : init_hardware
 * Returned Value   : void
 * Comments         :
 *   Initialize Kinetis device.
-*
+* Modifiziert für I-300 M. Bürki 02.07.2013
+* Kein Flexbus und kein MRAM beim I-300
 *END*-------------------------------------------------------------------------*/
-
 void init_hardware(void)
 {
-    
 #if PE_LDD_VERSION
     /*  Watch Dog disabled by CPU bean (need to setup in CPU Inspector) */
     __pe_initialize_hardware();
@@ -304,9 +404,11 @@ void init_hardware(void)
     /* Enable pin clocks */
     _bsp_gpio_io_init ();
     /* Initialize FlexBus */
-    _bsp_flexbus_setup();
+	// Kein Flexbus beim I-300
+    //_bsp_flexbus_setup();
     /* Initialize MRAM */
-    _bsp_flexbus_mram_setup((uint32_t)BSP_EXTERNAL_MRAM_RAM_BASE);
+	// Kein MRAM beim I-300
+    //_bsp_flexbus_mram_setup((uint_32)BSP_EXTERNAL_MRAM_RAM_BASE);
     /* Initialize SDRAM */
-    _bsp_ddr2_setup();
+    _bsp_ddr_setup();
 }
diff --git a/externals/MQX_4_1/mqx/source/io/enet/macnet/macnet_init.c b/externals/MQX_4_1/mqx/source/io/enet/macnet/macnet_init.c
index 4d443d1..833adbc 100644
--- a/externals/MQX_4_1/mqx/source/io/enet/macnet/macnet_init.c
+++ b/externals/MQX_4_1/mqx/source/io/enet/macnet/macnet_init.c
@@ -33,7 +33,7 @@
 #include "enet.h"
 #include "enetprv.h"
 #include "bsp_prv.h"
-#include "macnet_prv.h"          
+#include "macnet_prv.h"
 
 extern _mem_pool_id _BSP_sram_pool;
 
@@ -68,7 +68,7 @@ uint32_t MACNET_initialize
    (
       ENET_CONTEXT_STRUCT_PTR enet_ptr
    )
-{ 
+{
    MACNET_CONTEXT_STRUCT_PTR  macnet_context_ptr=NULL;
    ENET_MemMapPtr             macnet_ptr;
    VENET_BD_STRUCT_PTR        bd_ptr;
@@ -83,18 +83,18 @@ uint32_t MACNET_initialize
 
    // Initialize the MACNET I/O Pins
    MACNET_io_init(enet_ptr->PARAM_PTR->ENET_IF->MAC_NUMBER);
-   
+
    macnet_ptr = MACNET_get_base_address(enet_ptr->PARAM_PTR->ENET_IF->MAC_NUMBER);
    if (macnet_ptr == NULL) {
       return ENETERR_INVALID_DEVICE;
    }
-   
-   
+
+
    // currently limit number of TX BDs to 32, as a bitmask is used in the free function.
    if (enet_ptr->PARAM_PTR->NUM_TX_ENTRIES > 32) {
       return ENETERR_INVALID_INIT_PARAM;
    }
-   
+
    /*
    ** This function can be called from any context, and it needs mutual
    ** exclusion with itself.
@@ -104,8 +104,8 @@ uint32_t MACNET_initialize
    macnet_context_ptr = _mem_alloc_system_zero(sizeof(MACNET_CONTEXT_STRUCT));
    IF_ERROR_EXIT((NULL==macnet_context_ptr), ENETERR_ALLOC_MAC_CONTEXT);
    _mem_set_type((void *)macnet_context_ptr, MEM_TYPE_IO_ENET_MAC_CONTEXT_STRUCT);
-   
-   enet_ptr->MAC_CONTEXT_PTR = (void *) macnet_context_ptr;  
+
+   enet_ptr->MAC_CONTEXT_PTR = (void *) macnet_context_ptr;
 
    macnet_context_ptr->MACNET_ADDRESS = macnet_ptr;
    macnet_context_ptr->PHY_PTR = MACNET_get_base_address(enet_ptr->PARAM_PTR->ENET_IF->PHY_NUMBER);
@@ -118,9 +118,9 @@ uint32_t MACNET_initialize
    while ((macnet_ptr->ECR & ENET_ECR_RESET_MASK) && (timeout<MACNET_RESET_TIMEOUT)){
       _time_delay(1);
       timeout++;
-   } 
+   }
    IF_ERROR_EXIT((macnet_ptr->ECR & ENET_ECR_RESET_MASK), ENETERR_INIT_FAILED);
-   
+
    /* Disable all MACNET interrupts */
    macnet_ptr->EIMR = 0;
 
@@ -129,8 +129,8 @@ uint32_t MACNET_initialize
 
    macnet_context_ptr->NumRxBDs = enet_ptr->PARAM_PTR->NUM_RX_ENTRIES;
    macnet_context_ptr->NumTxBDs = enet_ptr->PARAM_PTR->NUM_TX_ENTRIES;
-     
-   // Compute aligned buffer sizes 
+
+   // Compute aligned buffer sizes
    if (enet_ptr->PARAM_PTR->TX_BUFFER_SIZE) {
       macnet_context_ptr->AlignedTxBufferSize = MACNET_TX_ALIGN(enet_ptr->PARAM_PTR->TX_BUFFER_SIZE);
    } else {
@@ -175,7 +175,7 @@ uint32_t MACNET_initialize
    macnet_context_ptr->RX_PCB_BASE = (MACNET_RX_PCB_PTR) _mem_alloc_system_zero(pcbsize);
    IF_ERROR_EXIT((NULL==macnet_context_ptr->RX_PCB_BASE), ENETERR_ALLOC_PCB);
    _mem_set_type((void *)macnet_context_ptr->RX_PCB_BASE, MEM_TYPE_IO_PCB_STRUCT);
-       
+
    // Allocate the Transmit and Receive buffers
    txsize = (enet_ptr->PARAM_PTR->NUM_TX_BUFFERS * macnet_context_ptr->AlignedTxBufferSize) + MACNET_TX_BUFFER_ALIGNMENT;
    rxsize = (enet_ptr->PARAM_PTR->NUM_RX_BUFFERS  * macnet_context_ptr->AlignedRxBufferSize) +MACNET_RX_BUFFER_ALIGNMENT;
@@ -188,7 +188,7 @@ uint32_t MACNET_initialize
 #else
    buf_ptr = _mem_alloc_system_uncached(rxsize + txsize + ssize + lsize);  // temporary fix for cache problems... previously _mem_alloc_system
 #endif
-   
+
    IF_ERROR_EXIT((NULL==buf_ptr), ENETERR_ALLOC_BUFFERS);
    _mem_set_type(buf_ptr, MEM_TYPE_IO_ENET_BUFFERS);
 
@@ -196,17 +196,17 @@ uint32_t MACNET_initialize
 
    // Align to TX buffer boundary
    buf_ptr = (unsigned char *)MACNET_TX_ALIGN((uint32_t)buf_ptr);
-   
+
    // Queue packets on TX Buffer Q.
    macnet_context_ptr->TX_BUFFERS = NULL;
    for (i=0;i<enet_ptr->PARAM_PTR->NUM_TX_BUFFERS;i++) {
       ENET_Enqueue_Buffer((void **)&macnet_context_ptr->TX_BUFFERS, buf_ptr);
       buf_ptr += macnet_context_ptr->AlignedTxBufferSize;
    }
-   
+
    // Align to RX buffer boundary
    buf_ptr = (unsigned char *)MACNET_RX_ALIGN((uint32_t)buf_ptr);
-  
+
    // Queue packets on RX Buffer Q.
    macnet_context_ptr->RX_BUFFERS = NULL;
    for (i=0;i<enet_ptr->PARAM_PTR->NUM_RX_BUFFERS;i++) {
@@ -226,14 +226,14 @@ uint32_t MACNET_initialize
       buf_ptr += large_packet_size;
    }
 
-   // Enqueue the RX PCBs onto the receive PCB queue 
+   // Enqueue the RX PCBs onto the receive PCB queue
    pcb_ptr = macnet_context_ptr->RX_PCB_BASE;
    for (i = 0; i < enet_ptr->PARAM_PTR->NUM_RX_PCBS; i++) {
       QADD(macnet_context_ptr->RxPCBHead, macnet_context_ptr->RxPCBTail, (PCB_PTR) pcb_ptr);
       pcb_ptr++;
-   } 
+   }
 
-   // Fill up the receive ring 
+   // Fill up the receive ring
    MACNET_add_buffers_to_rx_ring(macnet_context_ptr);
 
    /* Program this station's Ethernet physical address */
@@ -243,19 +243,19 @@ uint32_t MACNET_initialize
    macnet_ptr->IAUR = 0;
    macnet_ptr->IALR = 0;
 
-   // Clear the group hash table registers                                
+   // Clear the group hash table registers
    macnet_ptr->GAUR = 0;
-   macnet_ptr->GALR = 0;  
+   macnet_ptr->GALR = 0;
 
    /* Program receive buffer size */
-   macnet_ptr->MRBR = macnet_context_ptr->AlignedRxBufferSize;     
+   macnet_ptr->MRBR = macnet_context_ptr->AlignedRxBufferSize;
 
    // Configure start of Rx and Tx BD rings
    macnet_ptr->RDSR = (uint32_t)(macnet_context_ptr->MACNET_RX_RING_PTR);
    macnet_ptr->TDSR = (uint32_t)(macnet_context_ptr->MACNET_TX_RING_PTR);
 
-   // Set Receive Frame size 
-   // NOTE: Oddly, the Receive Control Register (RCR) afmacnetts the transmit side too.  The RCR is used to determine if the 
+   // Set Receive Frame size
+   // NOTE: Oddly, the Receive Control Register (RCR) afmacnetts the transmit side too.  The RCR is used to determine if the
    //       transmitter is babbling, which means, if the RX buffer size < Tx Buffer size, we can get babling transmitter
    //       errors if we set RCR to the maximum Receive frame length.  We really have no choice but to set RCR to one
    //       of ENET_FRAMESIZE or ENET_FRAMESIZE_VLAN.
@@ -272,7 +272,7 @@ uint32_t MACNET_initialize
         rcr |= ENET_RCR_RMII_10T_MASK;
    }
    macnet_ptr->RCR =  rcr;
-   
+
 
    if (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_MAC_LOOPBACK) {
       macnet_ptr->RCR |= ENET_RCR_LOOP_MASK;
@@ -283,13 +283,18 @@ uint32_t MACNET_initialize
    } else {
       macnet_ptr->TCR = 4; // full duplex
    }
-   
-   // Enable MII_SPEED register 
+
+   //TODO Test --> Martin
+   // Enable MII_SPEED register
+   // BUS_CLOCK ca. 83MHz oder 50MHz
+   // PHY_MII_SPEED sollte 1MHz sein
    i = (MACNET_device[enet_ptr->PARAM_PTR->ENET_IF->MAC_NUMBER].BUS_CLOCK / enet_ptr->PARAM_PTR->ENET_IF->PHY_MII_SPEED + 1) & ~1;
-   if (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_NO_PREAMBLE) {
+   if (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_NO_PREAMBLE)
+   {
       i |= ENET_MSCR_DIS_PRE_MASK;
    }
-   macnet_context_ptr->PHY_PTR->MSCR = i;
+   //FIT
+   macnet_context_ptr->PHY_PTR->MSCR = i + ENET_MSCR_HOLDTIME(7);
 
    // Zero counters
    macnet_ptr->MIBC |= ENET_MIBC_MIB_CLEAR_MASK;
@@ -297,14 +302,14 @@ uint32_t MACNET_initialize
    // Install the ISRs
    bOK = MACNET_install_isrs( enet_ptr, &MACNET_device[enet_ptr->PARAM_PTR->ENET_IF->MAC_NUMBER] );
    IF_ERROR_EXIT(!bOK, ENETERR_INSTALL_ISR);
-          
-   // Unmask transmit/receive interrupts 
-   // NOTE: need to enable both RXF and RXB, but only TXB, as RXB does not get generated with RXF, 
+
+   // Unmask transmit/receive interrupts
+   // NOTE: need to enable both RXF and RXB, but only TXB, as RXB does not get generated with RXF,
    //       but TXB does get generated with TXF
    // However, on 52259, enabling RXB is resulting in an HBERR interrupt. RXB is not required, so leave it disabled.
-   macnet_ptr->EIMR = ENET_EIR_TXB_MASK | ENET_EIR_RXF_MASK; 
+   macnet_ptr->EIMR = ENET_EIR_TXB_MASK | ENET_EIR_RXF_MASK;
 
-   // Enable MACNET 
+   // Enable MACNET
    macnet_ptr->ECR = (ENET_ECR_ETHEREN_MASK | ENET_ECR_EN1588_MASK);// | 0x100;
 
    // Discover PHY address if PHY_DISCOVER option is set
@@ -343,14 +348,14 @@ uint32_t MACNET_initialize
     if (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_HW_RX_PROTOCOL_CHECKSUM)
     {
         macnet_ptr->RACC |= ENET_RACC_PRODIS_MASK;  /* Discard of frames with wrong protocol checksum.*/
-    }  
-#endif 
+    }
+#endif
 #if BSPCFG_ENET_HW_RX_MAC_ERR
     if (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_HW_RX_MAC_ERR)
     {
         macnet_ptr->RACC |= ENET_RACC_LINEDIS_MASK; /* Discard of frames with MAC layer errors.*/
-    } 
-#endif                
+    }
+#endif
     if (
 #if BSPCFG_ENET_HW_TX_IP_CHECKSUM || BSPCFG_ENET_HW_TX_PROTOCOL_CHECKSUM
         (enet_ptr->PARAM_PTR->OPTIONS & (ENET_OPTION_HW_TX_IP_CHECKSUM|ENET_OPTION_HW_TX_PROTOCOL_CHECKSUM))||
@@ -358,8 +363,8 @@ uint32_t MACNET_initialize
         (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_STORE_AND_FORW) )
     {
         /* Transmit FIFO Watermark Register.
-         * The TFWR[STRFWD] bit must be set to use the checksum feature. 
-         * In this case, the MAC starts to transmit data only when a complete 
+         * The TFWR[STRFWD] bit must be set to use the checksum feature.
+         * In this case, the MAC starts to transmit data only when a complete
          * frame is stored in the transmit FIFO.*/
         macnet_ptr->TFWR = ENET_TFWR_STRFWD_MASK;
     }
@@ -381,7 +386,7 @@ uint32_t MACNET_initialize
    // Signals the MACNET that empty buffers are available.
    // It is NECESSARY to do this AFTER enabling the MACNET.
    macnet_ptr->RDAR = ENET_RDAR_RDAR_MASK;
-   
+
    //jm _mem_copy((void*)0x400d0000, (void*)0x3f400000, 0x400);
 
 
@@ -395,13 +400,13 @@ uint32_t MACNET_initialize
 
    bOK = _lwevent_create(&(macnet_ptp_ptr->LWEVENT_PTP), 0);
    IF_ERROR_EXIT(bOK, ENETERR_1588_LWEVENT);
-   
+
    macnet_ptp_ptr->TXSTAMP = (MACNET_PTP_TIME){0,0};
    macnet_ptp_ptr->L2PCKS_PTR = NULL;
-   
+
    macnet_context_ptr->PTP_PRIV = macnet_ptp_ptr;
    MACNET_ptp_init(enet_ptr);
-   
+
    if (macnet_ptp_ptr->PTIMER_PRESENT) {
       /* Set Timer count */
       MACNET_ptp_start(macnet_ptp_ptr, (enet_ptr->PARAM_PTR->OPTIONS & ENET_OPTION_PTP_MASTER_CLK));
@@ -425,6 +430,6 @@ EXIT:
    }
    MACNET_int_enable();
    return error;
-} 
+}
 
 /* EOF */
diff --git a/externals/MQX_4_1/rtcs/source/include/rtcscfg.h b/externals/MQX_4_1/rtcs/source/include/rtcscfg.h
index dfbb190..1f05fb1 100644
--- a/externals/MQX_4_1/rtcs/source/include/rtcscfg.h
+++ b/externals/MQX_4_1/rtcs/source/include/rtcscfg.h
@@ -30,7 +30,7 @@
 *   RTCSCFG_CHECK_ADDRSIZE                 1
 *   RTCSCFG_IP_DISABLE_DIRECTED_BROADCAST  0
 *   RTCSCFG_BOOTP_RETURN_YIADDR            0
-*   RTCSCFG_UDP_ENABLE_LBOUND_MULTICAST    0  
+*   RTCSCFG_UDP_ENABLE_LBOUND_MULTICAST    0
 *   RTCSCFG_LOG_SOCKET_API                 0
 *   RTCSCFG_LOG_PCB                        0
 *   RTCSCFG_LINKOPT_8023                   0
@@ -45,6 +45,16 @@
 #ifndef __rtcscfg_h__
 #define __rtcscfg_h__
 
+
+//---------------------------------------------------------------------------
+//FIT overwrite defaults
+#define RTCSCFG_IP_DISABLE_DIRECTED_BROADCAST    0
+#define RTCSCFG_SOCKET_PART_INIT   10
+#define RTCSCFG_SOCKET_PART_GROW  6
+#define RTCSCFG_PRECISE_TIME    1
+
+//---------------------------------------------------------------------------
+
 /***************************************************************************
 **
 ** Code and Data configuration options
@@ -52,7 +62,7 @@
 **
 */
 
-/* 
+/*
 ** IPv6 Protocol
 ** MGCT: <option type="bool"/>
 */
@@ -60,7 +70,7 @@
    #define RTCSCFG_ENABLE_IP6		0
 #endif
 
-/* 
+/*
 ** IPv4 Protocol
 ** MGCT: <option type="bool"/>
 */
@@ -68,7 +78,7 @@
    #define RTCSCFG_ENABLE_IP4		1
 #endif
 
-/* 
+/*
 ** ICMPv4 Protocol
 ** MGCT: <option type="bool"/>
 */
@@ -87,14 +97,14 @@
 ** MGCT: <option type="bool"/>
 */
 #ifndef RTCSCFG_ENABLE_NAT
-   #define RTCSCFG_ENABLE_NAT       0 
+   #define RTCSCFG_ENABLE_NAT       0
 #endif
 
 /*
 ** MGCT: <option type="bool"/>
 */
 #ifndef RTCSCFG_ENABLE_LWDNS
-   #define RTCSCFG_ENABLE_LWDNS  1 
+   #define RTCSCFG_ENABLE_LWDNS  1
 #endif
 
 /*
@@ -106,7 +116,7 @@
 
 #if RTCSCFG_ENABLE_DNS == 1
     #ifdef RTCSCFG_ENABLE_LOOPBACK
-        #undef  RTCSCFG_ENABLE_LOOPBACK      
+        #undef  RTCSCFG_ENABLE_LOOPBACK
     #endif
     #define RTCSCFG_ENABLE_LOOPBACK 1
     #ifdef RTCSCFG_ENABLE_LWDNS
@@ -203,7 +213,7 @@
 /*
 ** MGCT: <option type="bool"/>
 */
-#ifndef RTCSCFG_USE_KISS_RNG 
+#ifndef RTCSCFG_USE_KISS_RNG
    #define RTCSCFG_USE_KISS_RNG 0
 #endif
 
@@ -212,7 +222,7 @@
 /***************************************************************************
 **
 ** Error Checking options
-** 
+**
 ** MGCT: <category name="Error Checking Options">
 **
 ****************************************************************************/
@@ -259,7 +269,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** PCB Configuration options
 **
 ** MGCT: <category name="PCB Configuration Options">
@@ -279,7 +289,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_PCBS_GROW
-   #define RTCSCFG_PCBS_GROW 0 
+   #define RTCSCFG_PCBS_GROW 0
 #endif
 
 /*
@@ -287,13 +297,13 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef RTCSCFG_PCBS_MAX
-   #define RTCSCFG_PCBS_MAX RTCSCFG_PCBS_INIT 
+   #define RTCSCFG_PCBS_MAX RTCSCFG_PCBS_INIT
 #endif
 
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** Socket Configuration options
 **
 ** MGCT: <category name="Socket Configuration Options">
@@ -313,7 +323,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_SOCKET_PART_INIT
-  #define RTCSCFG_SOCKET_PART_INIT 6 
+  #define RTCSCFG_SOCKET_PART_INIT 6
 #endif
 
 /*
@@ -329,13 +339,13 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef RTCSCFG_SOCKET_PART_MAX
-   #define RTCSCFG_SOCKET_PART_MAX RTCSCFG_SOCKET_PART_INIT 
+   #define RTCSCFG_SOCKET_PART_MAX RTCSCFG_SOCKET_PART_INIT
 #endif
 
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** RTCS Message Configuration options
 **
 ** MGCT: <category name="RTCS Task and Message Options">
@@ -355,7 +365,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_MSGPOOL_GROW
-    #define RTCSCFG_MSGPOOL_GROW 2 
+    #define RTCSCFG_MSGPOOL_GROW 2
 #endif
 
 /*
@@ -363,7 +373,7 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef RTCSCFG_MSGPOOL_MAX
-    #define RTCSCFG_MSGPOOL_MAX RTCSCFG_MSGPOOL_INIT 
+    #define RTCSCFG_MSGPOOL_MAX RTCSCFG_MSGPOOL_INIT
 #endif
 
 /* MGCT: </category> */
@@ -394,12 +404,12 @@
    #define RTCSCFG_LINKOPT_8021Q_PRIO 0
 #endif
 
-/* 
-** RTCSCFG_DISCARD_SELF_BCASTS controls whether or not to discard all 
-** broadcast pkts that we sent, as they are likely echoes from older 
+/*
+** RTCSCFG_DISCARD_SELF_BCASTS controls whether or not to discard all
+** broadcast pkts that we sent, as they are likely echoes from older
 ** hubs
 ** MGCT: <option type="bool"/>
-*/ 
+*/
 #ifndef RTCSCFG_DISCARD_SELF_BCASTS
    #define RTCSCFG_DISCARD_SELF_BCASTS 1
 #endif
@@ -408,7 +418,7 @@
 
 
 /***************************************************************************
-** 
+**
 ** ARP Configuration options
 **
 ** MGCT: <category name="ARP Configuration Options">
@@ -428,7 +438,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef ARPALLOC_SIZE
-    #define ARPALLOC_SIZE 4 
+    #define ARPALLOC_SIZE 4
 #endif
 
 /*
@@ -442,7 +452,7 @@
 /*
 ** MGCT: <option type="number"/>
 */
-#ifndef RTCSCFG_ARPTIME_RESEND_MAX  
+#ifndef RTCSCFG_ARPTIME_RESEND_MAX
     #define RTCSCFG_ARPTIME_RESEND_MAX            30000     /* 30 sec */
 #endif
 
@@ -463,13 +473,13 @@
 /*
 ** Number of PCBs queued on an outstanding ARP
 ** Per RFC, Minimum recommended is 1.
-** When sending large UDP packets, which will result 
-** in IP fragmentations, set to at least the largest number of 
+** When sending large UDP packets, which will result
+** in IP fragmentations, set to at least the largest number of
 ** fragments
 ** MGCT: <option type="number"/>
 */
 #ifndef ARP_ENTRY_MAX_QUEUED_PCBS
-    #define ARP_ENTRY_MAX_QUEUED_PCBS 1 
+    #define ARP_ENTRY_MAX_QUEUED_PCBS 1
 #endif
 
 /*
@@ -486,7 +496,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** IPv4 Configuration options
 **
 ** MGCT: <category name="IPv4 Configuration Options">
@@ -497,35 +507,35 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef IPIFALLOC_SIZE
-    #define IPIFALLOC_SIZE 2 
+    #define IPIFALLOC_SIZE 2
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef IPROUTEALLOC_SIZE
-    #define IPROUTEALLOC_SIZE 2 
+    #define IPROUTEALLOC_SIZE 2
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef IPGATEALLOC_SIZE
-    #define IPGATEALLOC_SIZE 1 
+    #define IPGATEALLOC_SIZE 1
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef IPMCBALLOC_SIZE
-    #define IPMCBALLOC_SIZE 1 
+    #define IPMCBALLOC_SIZE 1
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef RADIXALLOC_SIZE
-    #define RADIXALLOC_SIZE 2 
+    #define RADIXALLOC_SIZE 2
 #endif
 
 /*
@@ -565,7 +575,7 @@
 
 
 /***************************************************************************
-** 
+**
 ** IGMP Configuration options
 **
 ** MGCT: <category name="IGMP Configuration Options">
@@ -586,7 +596,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** UDP Configuration options
 **
 ** MGCT: <category name="UDP Configuration Options">
@@ -598,7 +608,7 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef RTCSCFG_UDP_MAX_QUEUE_SIZE
-    #define RTCSCFG_UDP_MAX_QUEUE_SIZE 1 
+    #define RTCSCFG_UDP_MAX_QUEUE_SIZE 1
 #endif
 
 /*
@@ -616,7 +626,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** TCP Configuration options
 **
 ** MGCT: <category name="TCP Configuration Options">
@@ -639,20 +649,20 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_TCP_MAX_CONNECTIONS
-   #define RTCSCFG_TCP_MAX_CONNECTIONS      0  
+   #define RTCSCFG_TCP_MAX_CONNECTIONS      0
 #endif
 
 /*
 ** Maximum number of simultaneoushalf open connections allowed.
-** Define as 0 to disable the SYN attack recovery feature. 
+** Define as 0 to disable the SYN attack recovery feature.
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_TCP_MAX_HALF_OPEN
-   #define RTCSCFG_TCP_MAX_HALF_OPEN        0  
+   #define RTCSCFG_TCP_MAX_HALF_OPEN        0
 #endif
 
 #ifndef RTCSCFG_TCP_ACKDELAY
-    #define TCP_ACKDELAY                    1 
+    #define TCP_ACKDELAY                    1
 #else
     #if RTCSCFG_TCP_ACKDELAY > 500   /* Max ack delay, as per RFC1122 */
         #define TCP_ACKDELAY                500
@@ -665,7 +675,7 @@
 
 
 /***************************************************************************
-** 
+**
 ** RIP Configuration options
 **
 ** MGCT: <category name="RIP Configuration options">
@@ -684,7 +694,7 @@
 #endif
 
 #if RTCSCFG_ENABLE_RIP
-   #if !(RTCSCFG_ENABLE_IGMP && RTCSCFG_ENABLE_IP4) 
+   #if !(RTCSCFG_ENABLE_IGMP && RTCSCFG_ENABLE_IP4)
       #error RIP uses IGMP.  Enable RTCSCFG_ENABLE_IGMP or disable RTCSCFG_ENABLE_RIP in user_config.h
    #endif
 #endif
@@ -732,7 +742,7 @@
 
 
 /***************************************************************************
-** 
+**
 ** RTCS Configuration options
 **
 ** MGCT: <category name="RTCS Configuration Options">
@@ -745,7 +755,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_QUEUE_BASE
-    #define RTCSCFG_QUEUE_BASE 2 
+    #define RTCSCFG_QUEUE_BASE 2
 #endif
 
 /*
@@ -753,7 +763,7 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef RTCSCFG_STACK_SIZE
-    #define RTCSCFG_STACK_SIZE (750*sizeof(uint32_t)) 
+    #define RTCSCFG_STACK_SIZE (750*sizeof(uint32_t))
 #endif
 
 /* MGCT: </category> */
@@ -795,7 +805,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** IPCFG Configuration options
 **
 ** MGCT: <category name="IPCFG API Configuration Options">
@@ -852,7 +862,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** SMTP Client Configuration options
 **
 ** MGCT: <category name="SMTP Client Configuration options">
@@ -870,7 +880,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** FTP Client Configuration options
 **
 ** MGCT: <category name="FTP Client Configuration Options">
@@ -882,7 +892,7 @@
 ** MGCT: <option type="bool"/>
 */
 #ifndef FTPCCFG_SMALL_FILE_PERFORMANCE_ENHANCEMENT
-   #define FTPCCFG_SMALL_FILE_PERFORMANCE_ENHANCEMENT 1 
+   #define FTPCCFG_SMALL_FILE_PERFORMANCE_ENHANCEMENT 1
 #endif
 
 /*
@@ -894,7 +904,7 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef FTPCCFG_WINDOW_SIZE
-    #define FTPCCFG_WINDOW_SIZE 536 
+    #define FTPCCFG_WINDOW_SIZE 536
 #endif
 
 /*
@@ -907,7 +917,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** FTP Server Configuration options
 **
 ** MGCT: <category name="FTP Server Configuration Options">
@@ -922,7 +932,7 @@
 ** </option>
 */
 #ifndef FTPDCFG_SHUTDOWN_OPTION
-   #define FTPDCFG_SHUTDOWN_OPTION FLAG_ABORT_CONNECTION  
+   #define FTPDCFG_SHUTDOWN_OPTION FLAG_ABORT_CONNECTION
 #endif
 
 /*
@@ -932,7 +942,7 @@
 ** </option>
 */
 #ifndef FTPDCFG_DATA_SHUTDOWN_OPTION
-   #define FTPDCFG_DATA_SHUTDOWN_OPTION FLAG_CLOSE_TX  
+   #define FTPDCFG_DATA_SHUTDOWN_OPTION FLAG_CLOSE_TX
 #endif
 
 /*
@@ -969,7 +979,7 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef FTPDCFG_WINDOW_SIZE
-    #define FTPDCFG_WINDOW_SIZE 536 
+    #define FTPDCFG_WINDOW_SIZE 536
 #endif
 
 /*
@@ -978,34 +988,34 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef FTPDCFG_BUFFER_SIZE
-    #define FTPDCFG_BUFFER_SIZE 512 
+    #define FTPDCFG_BUFFER_SIZE 512
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef FTPDCFG_CONNECT_TIMEOUT
-   #define FTPDCFG_CONNECT_TIMEOUT 1000 
+   #define FTPDCFG_CONNECT_TIMEOUT 1000
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef FTPDCFG_SEND_TIMEOUT
-   #define FTPDCFG_SEND_TIMEOUT 5000 
+   #define FTPDCFG_SEND_TIMEOUT 5000
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef FTPDCFG_TIMEWAIT_TIMEOUT
-   #define FTPDCFG_TIMEWAIT_TIMEOUT 500 
+   #define FTPDCFG_TIMEWAIT_TIMEOUT 500
 #endif
 
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** Telnet Configuration options
 **
 ** MGCT: <category name="Telnet Configuration Options">
@@ -1016,14 +1026,14 @@
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef TELNETDCFG_BUFFER_SIZE
-    #define TELNETDCFG_BUFFER_SIZE 256 
+    #define TELNETDCFG_BUFFER_SIZE 256
 #endif
 
 /*
 ** MGCT: <option type="string" maxsize="256" quoted="false" allowempty="false"/>
 */
 #ifndef TELNETDCFG_NOWAIT
-   #define TELNETDCFG_NOWAIT FALSE 
+   #define TELNETDCFG_NOWAIT FALSE
 #endif
 
 /*
@@ -1037,27 +1047,27 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef TELENETDCFG_CONNECT_TIMEOUT
-   #define TELENETDCFG_CONNECT_TIMEOUT 1000 
+   #define TELENETDCFG_CONNECT_TIMEOUT 1000
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef TELENETDCFG_SEND_TIMEOUT
-   #define TELENETDCFG_SEND_TIMEOUT 5000 
+   #define TELENETDCFG_SEND_TIMEOUT 5000
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef TELENETDCFG_TIMEWAIT_TIMEOUT
-   #define TELENETDCFG_TIMEWAIT_TIMEOUT 1000 
+   #define TELENETDCFG_TIMEWAIT_TIMEOUT 1000
 #endif
 
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** SNMP Configuration options
 **
 ** MGCT: <category name="SNMP Configuration Options">
@@ -1078,7 +1088,7 @@
 /* MGCT: </category> */
 
 /***************************************************************************
-** 
+**
 ** PPPHDLC Message Configuration options
 **
 ** MGCT: <category name="PPPHDLC Message Configuration Options">
@@ -1089,21 +1099,21 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef PPPHDLC_INIT
-    #define PPPHDLC_INIT 6 
+    #define PPPHDLC_INIT 6
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef PPPHDLC_GROW
-    #define PPPHDLC_GROW 1 
+    #define PPPHDLC_GROW 1
 #endif
 
 /*
 ** MGCT: <option type="number"/>
 */
 #ifndef PPPHDLC_MAX
-    #define PPPHDLC_MAX PPPHDLC_INIT 
+    #define PPPHDLC_MAX PPPHDLC_INIT
 #endif
 
 /* MGCT: </category> */
@@ -1262,7 +1272,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef HTTPSRVCFG_DEF_SES_CNT
-#define HTTPSRVCFG_DEF_SES_CNT            (2) 
+#define HTTPSRVCFG_DEF_SES_CNT            (2)
 #endif
 
 /*
@@ -1316,20 +1326,20 @@
 #define HTTPSRVCFG_SES_TO                 (20000)
 #endif
 
-/* 
+/*
 ** Socket transmit buffer size
 ** MGCT: <option type="number"/>
 */
 #ifndef HTTPSRVCFG_TX_BUFFER_SIZE
-  #define HTTPSRVCFG_TX_BUFFER_SIZE    (1460) 
+  #define HTTPSRVCFG_TX_BUFFER_SIZE    (1460)
 #endif
 
-/* 
+/*
 ** Socket receive buffer size
 ** MGCT: <option type="number"/>
 */
 #ifndef HTTPSRVCFG_RX_BUFFER_SIZE
-  #define HTTPSRVCFG_RX_BUFFER_SIZE    (1460) 
+  #define HTTPSRVCFG_RX_BUFFER_SIZE    (1460)
 #endif
 
 /*
@@ -1364,7 +1374,7 @@
    #define HTTPSRVCFG_RECEIVE_TIMEOUT      (50)
 #endif
 
-/* 
+/*
 ** Default inet family configuration
 ** MGCT: <option type="string"/>
 */
@@ -1387,7 +1397,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_ND6_NEIGHBOR_CACHE_SIZE
-   #define RTCSCFG_ND6_NEIGHBOR_CACHE_SIZE      (5) 
+   #define RTCSCFG_ND6_NEIGHBOR_CACHE_SIZE      (5)
 #endif
 
 /*
@@ -1395,7 +1405,7 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_ND6_PREFIX_LIST_SIZE
-    #define RTCSCFG_ND6_PREFIX_LIST_SIZE        (4) 
+    #define RTCSCFG_ND6_PREFIX_LIST_SIZE        (4)
 #endif
 
 /*
@@ -1420,10 +1430,10 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_IP6_IF_ADDRESSES_MAX
-    #define RTCSCFG_IP6_IF_ADDRESSES_MAX        (5) 
+    #define RTCSCFG_IP6_IF_ADDRESSES_MAX        (5)
 #endif
 /* Check minimum value.*/
-#if RTCSCFG_IP6_IF_ADDRESSES_MAX < 2   
+#if RTCSCFG_IP6_IF_ADDRESSES_MAX < 2
     #undef RTCSCFG_IP6_IF_ADDRESSES_MAX
     #define RTCSCFG_IP6_IF_ADDRESSES_MAX        (2)
 #endif
@@ -1433,11 +1443,11 @@
 ** MGCT: <option type="number"/>
 */
 #ifndef RTCSCFG_IP6_IF_DNS_MAX
-    #define RTCSCFG_IP6_IF_DNS_MAX              (2) 
+    #define RTCSCFG_IP6_IF_DNS_MAX              (2)
 #endif
 
 
-/**  Maximum number of unique IPv6 multicast memberships that may exist at 
+/**  Maximum number of unique IPv6 multicast memberships that may exist at
 **  the same time in the whole system.
 ** MGCT: <option type="number"/>
 */
@@ -1450,7 +1460,7 @@
     #define RTCSCFG_IP6_MULTICAST_MAX        (RTCSCFG_IP6_IF_ADDRESSES_MAX+1)
 #endif
 
-/** Maximum number of IPv6 multicast memberships that may exist at 
+/** Maximum number of IPv6 multicast memberships that may exist at
  *  the same time per one socket.
 ** MGCT: <option type="number"/>
 */
@@ -1458,7 +1468,7 @@
     #define RTCSCFG_IP6_MULTICAST_SOCKET_MAX    (1)
 #endif
 
-/* 
+/*
 ** Multicast Listener Discovery (MLDv1) Protocol.
 ** MGCT: <option type="bool"/>
 */
@@ -1484,13 +1494,13 @@
 
 
 /* Check minimum values.*/
-#if RTCSCFG_ND6_ROUTER_LIST_SIZE < 1 
+#if RTCSCFG_ND6_ROUTER_LIST_SIZE < 1
     #error RTCSCFG_ND6_ROUTER_LIST_SIZE should be > 0
 #endif
 #if RTCSCFG_ND6_NEIGHBOR_CACHE_SIZE  < 1
     #error RTCSCFG_ND6_NEIGHBOR_CACHE_SIZE should be > 0
 #endif
-#if RTCSCFG_ND6_PREFIX_LIST_SIZE < 1 
+#if RTCSCFG_ND6_PREFIX_LIST_SIZE < 1
     #error RTCSCFG_ND6_PREFIX_LIST_SIZE should be > 0
 #endif
 
@@ -1503,9 +1513,9 @@
 ** follow-up retransmissions.
 ** MGCT: <option type="number"/>
 */
-#ifndef RTCSCFG_ND6_DAD_TRANSMITS 
+#ifndef RTCSCFG_ND6_DAD_TRANSMITS
     #define RTCSCFG_ND6_DAD_TRANSMITS           (1) /* If RTCSCFG_ND6_DAD_TRANSMITS = 0, the DAD is disabled.*/
-#endif  
+#endif
 
 /*
 ** Recursive DNS Server Option (RFC6106) support.
@@ -1528,7 +1538,7 @@
     #undef RTCSCFG_ND6_RDNSS_LIST_SIZE
     #define RTCSCFG__ND6_RDNSS_LIST_SIZE        (1)
 #endif
-  
+
 
 /*
 ** MGCT: <option type="bool"/>
